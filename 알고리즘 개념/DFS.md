* 그래프 탐색 : 하나의 정점으로부터 시작하여 차례대로 모든 정점들을 한 번씩 방문하는 것 (그래프에 대한 개념 후에 하나 만들기)
- 그래프은 정점과 간선의 집합 

--

## DFS (Depth-First Search) - 깊이 우선 탐색
- 해당 알고리즘의 이름과 같이 넓이 우선이 아닌 깊이 우선으로 미로 찾기에서 하나의 길로 쭉 가다가 길이 막힐 경우 다시 원래 장소로 돌아와 다른 branch로 탐색하는 것
- 모든 노드를 방문하고자 할 때 활용!

### 특징
- 자기 자신을 호출하는 순환 알고리즘의 특성을 지닌다.
- 노드의 방문 여부를 반드시 검사하여야 한다
	- ex) bool visited[max] 와 같은 변수를 통해
	- OR 무한 루프에 빠질 위험이 있다


### 탐색 과정
![그림으로 살펴보기](https://gmlwjd9405.github.io/images/algorithm-dfs-vs-bfs/dfs-example.png)

1. a 노드(시작 노드)를 방문한다.
	- 방문한 노드는 방문했다고 표시한다.
2. a와 인접한 노드들을 차례로 순회한다.
	- a와 인접한 노드가 없다면 종료한다.
	- a와 이웃한 노드 b를 방문했다면, a와 인접한 또 다른 노드를 방문하기 전에 b의 이웃 노드들을 전부 방문해야 한다.
3. b를 시작 정점으로 DFS를 다시 시작하여 b의 이웃 노드들을 방문한다.
4. b의 분기를 전부 완벽하게 탐색했다면 다시 a에 인접한 정점들 중에서 아직 방문이 안 된 정점을 찾는다.
	- 즉, b의 분기를 전부 완벽하게 탐색한 뒤에야 a의 다른 이웃 노드를 방문할 수 있다는 뜻이다.
5. 아직 방문이 안 된 정점이 없으면 종료한다. 있으면 다시 그 정점을 시작 정점으로 DFS를 시작한다.

<https://gmlwjd9405.github.io/2018/08/14/algorithm-dfs.html>

### 구현 방법
1. 순환 호출
2. 명시적 스텍 
	- 방문하였던 노드들을 스텍에 넣어두었다가 다시 꺼내어 사용하는 방법


### 시간복잡도
- DFS는 그래프(정점의 수: N, 간선의 수: E)의 모든 간선을 조회한다.
- 인접 리스트로 표현된 그래프: O(N+E)
- 인접 행렬로 표현된 그래프: O(N^2)
	- 즉, 그래프 내에 적은 숫자의 간선만을 가지는 희소 그래프(Sparse Graph) 의 경우 인접 행렬보다 인접 리스트를 사용하는 것이 유리하다. .. => 희소 그래프란..?

<https://kks227.blog.me/220857597424?Redirect=Log&from=postView> 읽고 이해하고 내용 정리하기!!! 과제^^

## BFS


## DFS VS BFS (비교)